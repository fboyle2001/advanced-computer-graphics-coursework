from typing import List, Tuple

import time
from vertex_graph import VertexGraph

class OBJModel:
    def __init__(self, file_name: str, graph: VertexGraph, preserved_headers: List[str]):
        self.isolated_name = '.'.join(file_name.split(".")[:-1])
        self.graph = graph
        self.preserved_headers = preserved_headers

    def write(self) -> str:
        return write_obj_file(self)

    def reduce(self, iterations: int) -> Tuple[int, int]:
        start_polygon_count = len(self.graph.compute_all_polygons())

        for _ in range(iterations):
            a, b = self.graph.determine_preferred_collapsible_edge()
            self.graph.collapse_edge(a, b)

        end_polygon_count = len(self.graph.compute_all_polygons())
        return start_polygon_count, end_polygon_count

def process_obj_file(file_name: str) -> OBJModel:
    graph = VertexGraph()
    preserved_headers = []

    def process_vertex(arguments):
        graph.add_node(str(len(graph.indices) + 1), tuple(float(coord) for coord in arguments))

    def process_texture(arguments):
        # print("Texture", arguments)
        return

    def process_normal(arguments):
        # print("Normal", arguments)
        return

    def process_free_form(arguments):
        assert False, "Not handling free form"

    def process_face(arguments):
        assert len(arguments) == 3, f"Only triangles are supported, received {len(arguments)} vertices for a polygon"
        # print("Face", arguments)

        face_indices = [str(arg.split("/")[0]) for arg in arguments]
        graph.add_edge(face_indices[0], face_indices[1])
        graph.add_edge(face_indices[0], face_indices[2])
        graph.add_edge(face_indices[1], face_indices[2])

    def process_line(arguments):
        assert False, "Not handling line"

    def process_comment(arguments):
        # Ignore comments
        return

    def process_other(op_code, arguments):
        if op_code != "usemtl":
            preserved_headers.append(f"{op_code} {' '.join(arguments)}")

    op_codes = {
        "v": process_vertex,
        "vt": process_texture,
        "vn": process_normal,
        "vp": process_free_form,
        "f": process_face,
        "l": process_line,
        "#": process_comment
    }

    with open(file_name, "r") as fp:
        for item_line in fp.readlines():
            item_line = item_line.strip()
            
            if len(item_line) == 0:
                continue
            
            whitespace_split = item_line.split(" ")
            op_code = whitespace_split[0]
            arguments = whitespace_split[1:]

            if op_code not in op_codes.keys():
                process_other(op_code, arguments)
            else:
                op_codes[op_code](arguments)
    
    return OBJModel(file_name, graph, preserved_headers)

def write_obj_file(obj_model: OBJModel) -> str:
    current_time = time.time()

    lines = [
        f"# Generated by progressive_generator.py at {current_time}",
        "# Preserved Headers",
        *obj_model.preserved_headers
    ]

    lines.append("")
    lines.append("# Vertices")

    real_index_map = {}

    for real_index, index in enumerate(obj_model.graph.indices, 1):
        x, y, z = obj_model.graph.index_data[index]
        lines.append(f"v {x} {y} {z}")
        real_index_map[index] = real_index

    lines.append("")
    lines.append("# Polygon Faces")

    for a, b, c in obj_model.graph.compute_all_polygons():
        real_a, real_b, real_c = real_index_map[a], real_index_map[b], real_index_map[c]
        lines.append(f"f {real_a}// {real_b}// {real_c}//")

    new_file_name = f"{obj_model.isolated_name}_reduced_{current_time}.obj"
    with open(new_file_name, "w+") as fp:
        for line in lines:
            fp.write(f"{line}\n")

    return new_file_name